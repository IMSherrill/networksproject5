#!/usr/bin/env python

import os
import sys
import socket
import select
import time
import json
import random
from datetime import datetime
from pprint import pprint

# # this keeps it from printing out, useful for when running ./test
# f = open(os.devnull, 'w')
# sys.stdout = f
#TODO: no-op


class LogEntry:

    def __init__(self, initial_data):
        for key in initial_data:
            setattr(self, key, initial_data[key])
            self.committed = False

    def __repr__(self):
        return "<log at index {}>".format(self.index)
        # if self.command == 'put':
        # return "{}    {} -> {}".format(self.term, self.key, self.value)

        # if self.command == 'get':
        #         return "{}     client <- {}".format(self.term, self.key)

    def toDict(self):
        return {
            'command': self.command,
            'key': self.key,
            'value': self.value,
            'term': self.term,
            'index': self.index,
            'src': self.src,
            'MID': self.MID
        }

    # TODO: why isnt this working?
    def commit(self):
        if not self.committed:
            statemachine[self.key] = self.value
            value = self.value
            self.committed = True
        else:
            pass


def send(msg):
    sock.sendall(json.dumps(msg))
        


def getIndexOfEntryWithThisMID(mid):
    index = 0
    while index < len(transactionlog):
        if transactionlog[index].MID == mid:
            return index


def MakeSureEverythingIsInOrder():
    pass

my_id = sys.argv[1]
replica_ids = sys.argv[2:]
all_ids = [my_id] + replica_ids
counter = 0
state = 'candidate'
currentterm = 0
votedForMe = []
myvotes = {}
need_to_send_was_leader = False
# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
try:
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
    sock.connect(my_id)
    time.sleep(0.5)
except:
    print 'hiiiiii'
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
    sock.connect(my_id)


last = 0

leader = 'FFFF'
test = 0
hearFromLeader = time.time()
readytovote = False
electionclock = time.time()
timeoutlength = random.uniform(.350, .500)
keepaliveclock = time.time()

transactionlog = []
statemachine = {}

lastlogIndex = 0
LastCommittedIndex = 0
MID_log = []
messageLog = {}
replicaCommitIndeces = {}
message_queue_put  = []
message_queue_get = []
server_responded_true = []
server_response_states = {}
failing_servers = []
messageToClient = []
time_since_last_commit = time.time()
for rid in replica_ids:
    server_response_states[rid] = {'nextIndex': 0,
                                   'matchIndex': 0}
# play with this value for optimization + latecny (bigger is better)
FILL_CHUNK_SIZE = 80
def heartbeat():
    global message_queue_get
    if len(message_queue_get) > 0 and LastCommittedIndex > 0:
        for msg in message_queue_get:
            response_value = statemachine.get(msg['key'], False)
            if response_value:
                getresponse_msg = {
                    'src': my_id,
                    'dst': msg['src'],
                    'leader': leader,
                    'type': 'ok',
                    'MID': msg['MID'],
                    'value': response_value,
                }
                send(getresponse_msg)
            else:
                failresponse_msg = {
                    'src': my_id,
                    'dst': msg['src'],
                    'leader': leader,
                    'type': 'fail',
                    'MID': msg['MID'],
                }
                send(failresponse_msg)
        message_queue_get = []


    for rid in replica_ids:
        entry_list = []
        prevLogIndex = max(server_response_states[rid]['nextIndex'] - 1, 0)
        prevLogTerm = transactionlog[prevLogIndex].term
        if prevLogIndex == 0:
            start_point = -1
        else:
            start_point = prevLogIndex
        for x in range(start_point, len(transactionlog)):
            entry_list.append(transactionlog[x].toDict())
        if len(entry_list) > FILL_CHUNK_SIZE:
            entry_list = entry_list[:FILL_CHUNK_SIZE]
        appendentry_msg = {
            'src': my_id,
            'dst': rid,
            'leader': leader,
            'type': 'append-entries',
            'entry': entry_list,
            'term': currentterm,
            'leaderCommit': LastCommittedIndex,
            'prevLogIndex': prevLogIndex,
            'prevLogTerm': prevLogTerm,
            'nextIndex': server_response_states[rid]['nextIndex']
        }

        send(appendentry_msg)
while True:
    lastlogIndex = len(transactionlog) - 1

    ready = select.select([sock], [], [], 0)[0]

    now = time.time()
    if state != 'leader' and now - electionclock > timeoutlength:
        timeoutlength = random.uniform(0.350, 0.500)
        readytovote = True

    if state == 'leader':
        now = time.time()
        if now - keepaliveclock > 0.150:
            keepaliveclock = time.time()
            counter += 1
            heartbeat()



    if readytovote:
        currentterm += 1
        print "{} requesting vote updating to term {}".format(my_id, currentterm)
        if len(transactionlog) > 0:
            prevLogTerm = transactionlog[-1].term
        else:
            prevLogTerm = 0
        state = 'candidate'
        election_msg = {
            'src': my_id,
            'leader': 'FFFF',
            'dst': 'FFFF',
            'type': 'requestvote',
            'term': currentterm,
            'prevLogTerm': prevLogTerm,
            'lengthOfLog': len(transactionlog)
        }
        send(election_msg)
        electionclock = time.time()
        votedForMe = [my_id]
        myvotes[currentterm] = my_id
        readytovote = False

    #######################
    #  RECIEVING MESSAGE  #
    #######################
    if sock in ready:
        t0 = time.time()
        msg_raw = sock.recv(64000)
 
        if len(msg_raw) == 0:
            continue
        msg = json.loads(msg_raw)

        if msg['src'] == leader:
            hearFromLeader = time.time()


        if msg['type'] in ['get', 'put']:
            if state == 'leader':
                if msg['type'] == 'get':
                    response_value = False
                    key = msg['key']
                    # TODO: if there is no value for that key respond with
                    # empty string
                    response_value = statemachine.get(key, False)
                    if response_value:
                        getresponse_msg = {
                            'src': my_id,
                            'dst': msg['src'],
                            'leader': leader,
                            'type': 'ok',
                            'MID': msg['MID'],
                            'value': response_value,
                        }
                        send(getresponse_msg)

                    else:
                        failresponse_msg = {
                            'src': my_id,
                            'dst': msg['src'],
                            'leader': leader,
                            'type': 'fail',
                            'MID': msg['MID'],
                        }
                        send(failresponse_msg)

                elif msg['type'] == 'put':
                    if msg['MID'] in MID_log:
                        continue
                    key = msg['key']
                    value = msg['value']

                    entrydict = {
                        'command': msg['type'],
                        'key': key,
                        'value': value,
                        'term': currentterm,
                        'MID': msg['MID'],
                        'index': len(transactionlog),
                        'src': msg['src']

                    }
                    entry = LogEntry(entrydict)
                    transactionlog.append(entry)
                    # append and lenth is one more than last index
                    for rid in replica_ids:
                        entry_list = []
                        prevLogIndex = max(server_response_states[rid]['nextIndex'] - 1, 0)
                        prevLogTerm = transactionlog[prevLogIndex].term
                        for x in range(prevLogIndex + 1, len(transactionlog)):
                            entry_list.append(transactionlog[x].toDict())
                        if len(entry_list) > FILL_CHUNK_SIZE:
                            entry_list = entry_list[:FILL_CHUNK_SIZE]

                        appendentry_msg = {
                            'src': my_id,
                            'dst': rid,
                            'leader': leader,
                            'type': 'append-entries',
                            'entry': entry_list,
                            'term': currentterm,
                            'leaderCommit': LastCommittedIndex,
                            'prevLogIndex': prevLogIndex,
                            'prevLogTerm': prevLogTerm,
                            'nextIndex': server_response_states[rid]['nextIndex'],
                        }
                        send(appendentry_msg)
                        if rid in failing_servers:
                            pass
                        else:
                            server_response_states[rid]['nextIndex'] = server_response_states[rid]['nextIndex'] + 1

            elif state == 'candidate':
                if 'redirect_from_leader' in msg:

                    continue
                redirect_msg = {
                    'src': my_id,
                    'dst': msg['src'],
                    'leader': leader,
                    'type': 'redirect',
                    'MID': msg['MID']
                }
                send(redirect_msg)
                continue

            else:  # redirect client to the leader
                if 'redirect_from_leader' in msg:
                    msg['dst'] = leader
                    send(msg)
                    continue
                redirect_msg = {
                    'src': my_id,
                    'dst': msg['src'],
                    'leader': leader,
                    'type': 'redirect',
                    'MID': msg['MID']
                }
                send(redirect_msg)
                continue

        if msg['type'] == 'requestvote':
            if currentterm > msg['term']:
                continue
            if currentterm < msg['term']:
                currentterm = msg['term']
                state = 'follower'
            if len(transactionlog) > 0:
                prevLogTerm = transactionlog[-1].term
            else:
                prevLogTerm = 0
            if (not myvotes.get(msg['term'])) and (msg['lengthOfLog'] >= len(transactionlog)) and (msg['prevLogTerm'] >= prevLogTerm):
                candidate = msg['src']
                vote_msg = {
                    'leader': 'FFFF',
                    'type': 'vote',
                    'vote': candidate,
                    'term': currentterm,
                    'dst': candidate,
                    'src': my_id
                }
                send(vote_msg)
                electionclock = time.time()
                myvotes[currentterm] = candidate
            else:  # I already voted this term
                pass

        if msg['type'] == 'vote' and state == 'candidate':
            candidate = msg['vote']
            electionterm = msg['term']
            if msg['term'] > currentterm:
                currentterm = msg['term']
                state = 'follower'
                leader = msg['leader']
                hearFromLeader = time.time()
                continue
            if candidate == my_id:
                if electionterm == currentterm:
                    if not msg['src'] in votedForMe:
                        votedForMe.append(msg['src'])

                        if len(votedForMe) > len(all_ids) / 2:
                            leader = my_id
                            print '{} is the leader'.format(my_id)
                            state = 'leader'

                            for msg in message_queue_put:
                                key = msg['key']
                                value = msg['value']

                                entrydict = {
                                    'command': msg['type'],
                                    'key': key,
                                    'value': value,
                                    'term': currentterm,
                                    'MID': msg['MID'],
                                    'index': len(transactionlog),
                                    'src': msg['src']

                                }
                                entry = LogEntry(entrydict)
                                transactionlog.append(entry)
                            message_queue_put = []

                            #NO-OP
                            entrydict = {
                                    'command': 'no-op',
                                    'key': '-1',
                                    'value': '-1',
                                    'term': currentterm,
                                    'MID': 'FLabbergasted',
                                    'index': len(transactionlog),
                                    'src': my_id

                                }
                            entry = LogEntry(entrydict)
                            transactionlog.append(entry)

                            for rid in replica_ids:
                                server_response_states[rid] = {'nextIndex': len(transactionlog) - 1,
                                'matchIndex': 0}
                            #TODO: NO-OP
                            time_since_last_commit = time.time()
                            heartbeat()


                else:
                    pass
                    # return false, voting for a previous term cannot go back
                    # in time
                    #TODO: add messsage queueing
            continue
        if msg['type'] == 'append-entries':
            allowCommit = False
            # check if the the index of the incoming entry is one more than
            # the current entry we are on
            if (msg['term'] > currentterm and state == 'leader') or need_to_send_was_leader:
                state = 'follower'
                currentterm = msg['term']
                leader = msg['leader']
                electionclock = time.time()
                for x in range(LastCommittedIndex + 1, len(transactionlog)):
                    currentTransaction = transactionlog[x]
                    redirect_msg = {
                    'src': currentTransaction.src,
                    'dst': leader,
                    'leader': leader,
                    'type': 'put',
                    'key': currentTransaction.key,
                    'value': currentTransaction.value,
                    'MID': currentTransaction.MID,
                    'redirect_from_leader': 'True'
                    }
                    send(redirect_msg)
                    need_to_send_was_leader = False

            if msg['term'] >= currentterm and state == 'candidate':
                print msg
                state = 'follower'
                currentterm = msg['term']
                leader = msg['leader']
                for msg_2 in message_queue_put + message_queue_get:
                    redirect_msg = {
                            'src': my_id,
                            'dst': msg_2['src'],
                            'leader': leader,
                            'type': 'redirect',
                            'matchIndex': len(transactionlog) - 1,
                            'MID': msg_2['MID']
                            }
                    send(redirect_msg)
                electionclock = time.time()
                message_queue_put = []
                message_queue_get = []

            if msg['term'] >= currentterm and state == 'follower':
                currentterm = msg['term']
                leader = msg['leader']
                for msg_2 in message_queue_put + message_queue_get:
                    redirect_msg = {
                            'src': my_id,
                            'dst': msg_2['src'],
                            'leader': leader,
                            'type': 'redirect',
                            'matchIndex': len(transactionlog) - 1,
                            'MID': msg_2['MID']
                            }
                    send(redirect_msg)
                electionclock = time.time()
                message_queue_put = []
                message_queue_get = []


            if len(transactionlog) + 1 < msg['nextIndex']:
                
                response_msg = {
                    'src': my_id,
                    'dst': msg['src'],
                    'leader': leader,
                    'term': currentterm,
                    'success': 'False',
                    'matchIndex': len(transactionlog) - 1,
                    'type': 'append-entry-response',
                    'boolean_test': 'False'
                }
                send(response_msg)
                continue
            if len(transactionlog) > 0:
                lastEntry = transactionlog[-1]
                expectedIndex = lastEntry.index + 1
                # check for syncing issues wih partioning and leaders
                if msg['term'] < currentterm:
                    response_msg = {
                        'src': my_id,
                        'dst': msg['src'],
                        'leader': leader,
                        'term': currentterm,
                        'success': 'False',
                        'matchIndex': len(transactionlog) - 1,
                        'type': 'append-entry-response',
                        'boolean_test': 'False'
                    }
                    send(response_msg)
                    continue
                reject_transaction = 0
                boolean_test = False
                for prevAppend in reversed(transactionlog):
                    if (prevAppend.term == msg['prevLogTerm'] and prevAppend.index == msg['prevLogIndex']):
                        allowCommit = True
                    elif (prevAppend.index == msg['prevLogIndex']):
                        reject_transaction = prevAppend
                        boolean_test = True
                if msg['prevLogIndex'] == 0:
                    allowCommit = True

                if not allowCommit:
                    if reject_transaction != 0:
                        bad_index_list = [transaction.index for transaction in transactionlog if transaction.term == reject_transaction.term]
                        bad_index = min(bad_index_list)
                        reject_transaction = 0
                    else:
                        bad_index = len(transactionlog) - 1
                        boolean_test = False
                    response_msg = {
                        'src': my_id,
                        'dst': msg['src'],
                        'term': currentterm,
                        'success': 'False',
                        'leader': leader,
                        'matchIndex': bad_index,
                        'type': 'append-entry-response',
                        'boolean_test': boolean_test
                    }
                    send(response_msg)
                    boolean_test = False
                    continue
                if len(transactionlog) > msg['nextIndex']:
                    new_length = len(transactionlog) - msg['nextIndex']
                    transactionlog = transactionlog[:-new_length]

            for newEntry in msg['entry']:
                if newEntry['index'] < len(transactionlog):
                    if newEntry['term'] == transactionlog[newEntry['index']].term:
                        pass
                    else:
                        transactionlog = transactionlog[:newEntry['index']]
                else:
                    entry = LogEntry(newEntry)
                    transactionlog.append(entry)
            if len(transactionlog) > 0 and msg['leaderCommit'] > LastCommittedIndex: 
                #Are all these operations necessary TODO
                up_to_here = min(len(transactionlog) - 1, msg['leaderCommit'])
                for x in range(LastCommittedIndex + 1, up_to_here + 1):
                    MID_log.append(transactionlog[x].MID)
                    transactionlog[x].commit()
                LastCommittedIndex = min(msg['leaderCommit'], len(transactionlog) - 1)
            #commit up to what master says is committed

            appendentry_response_msg = {
                'leader': leader,
                'term': currentterm,
                'src': my_id,
                'dst': leader,
                'type': 'append-entry-response',
                'matchIndex': len(transactionlog) - 1,
                'success': 'True',
            }
            send(appendentry_response_msg)


        if msg['type'] == 'append-entry-response':
            # replicaCommitIndeces[msg['src']] = msg['LastCommittedIndex']
            if msg['term'] > currentterm and state == 'leader':
                state = 'follower'
                currentterm = msg['term']
                leader = msg['leader']
                hearFromLeader = time.time()
                need_to_send_was_leader = True
                continue
            if msg['success'] == 'True' and state == 'leader' and msg['term'] == currentterm:
                if msg['src'] in failing_servers:
                    failing_servers.remove(msg['src'])
                    server_response_states[msg['src']]['nextIndex']  = msg['matchIndex'] + 1
                if not msg['src'] in server_response_states:
                    continue

                server_response_states[str(msg['src'])]['matchIndex'] = msg['matchIndex']
                server_response_states[str(msg['src'])]['nextIndex'] = msg['matchIndex']  + 1
                
                lowest_match_index = -1
                for server,value in server_response_states.iteritems():
                    currentValue = value['matchIndex']
                    total_at_lowest = 0
                    if currentValue > lowest_match_index:
                        for server, value in server_response_states.iteritems():
                            if value['matchIndex'] >= currentValue:
                                total_at_lowest += 1
                    if total_at_lowest + 1 > len(all_ids)/2:
                        lowest_match_index = currentValue

                if lowest_match_index > LastCommittedIndex:
                    for x in range(LastCommittedIndex + 1, lowest_match_index + 1):
                        currentTransaction = transactionlog[x]
                        if not currentTransaction.committed and (not currentTransaction.MID in MID_log):
                            MID_log.append(currentTransaction.MID)
                            currentTransaction.commit()
                            response_msg = {
                            'src':  my_id,
                            'dst':  currentTransaction.src,
                            'leader': leader,
                            'type': 'ok',
                            'MID': currentTransaction.MID,
                            }
                            if currentTransaction.MID != 'FLabbergasted':
                                send(response_msg)
                    LastCommittedIndex = lowest_match_index
                    time_since_last_commit = time.time()
            elif msg['success'] == 'False' and state == 'leader':
                if not (msg['src'] in failing_servers):
                    failing_servers.append(msg['src'])
                    if msg['boolean_test'] == 'True':
                        bad_term = [transaction.term for transaction in transactionlog if transaction.index == msg['matchIndex']]
                        matchIndex = min(transaction.index for transaction in transactionlog if transaction.term == bad_term)
                        server_response_states[msg['src']]['nextIndex'] = max(matchIndex, 0)
                    else:
                        server_response_states[msg['src']]['nextIndex'] = max(msg['matchIndex'], 0)

                server_response_states[msg['src']]['nextIndex'] = max(server_response_states[msg['src']]['nextIndex'] - 1, 0)

# 1  Add basic support for responding to client get() and put() requests. At this point, you can respond to all requests with a "type": "fail" message.
# 2  Implement the Raft election protocol (section 5.2 of the Raft paper); add the ability to respond to get() and put() requests with "type": "redirect" messages.
# 3  Add a timeout to detect leader failures (i.e. if you don't hear from the leader in X milliseconds...) and make sure that the new election proceeds correctly.
# 4  Implement a basic, empty version of the AppendEntries RPC call that doesn't replicate any data, but acts as a keepalive message from the leader to other replicas to prevent unnecessary elections.
# 5  Implement the transaction log and the "state machine" (i.e. a
# dictionary containing the key/value pairs from clients, Section 5.3).
# Don't bother replicating the transactions, just ensure that the leader
# is able to correctly answer get() and put() requests.

# 6  Improve your AppendEntries RPC call to actually send data to
# replicas. Ensure that updates are only committing when a quorum is in
# agreement.

# 7  Add support for retrying failed commits and test it by experimenting with lossy network simulations.
# 8  If you haven't already, modify the leader election to support the additional restrictions in Section 5.4.1; test your implementation on lossy networks with failed leaders.
# 9  Implement the subtle commit restriction given in Section 5.4.2.
# 10 Test, test, test, and test some more ;)
# Step 6 will probably require the most time in terms of writing code and
# debugging, since it is the crux of the algorithm. Implementing steps 7-9
# are necessary to ensure correctness of the protocol, but shouldn't be
# too difficult.
