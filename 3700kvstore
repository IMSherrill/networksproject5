#!/usr/bin/env python

import sys
import socket
import select
import time
import json
import random
from datetime import datetime

class LogEntry:
        def __init__(self, command, key, value, term):
                self.command = command
                self.key = key
                self.value = value
                self.term = term


        def __repr__(self):
                if self.command == 'put':
                        return "{}    {} -> {}".format(self.term, self.key, self.value)

                if self.command == 'get':
                        return "{}     client <- {}".format(self.term, self.key)


def send(msg):
	sock.send(json.dumps(msg))


my_id = sys.argv[1]
replica_ids = sys.argv[2:]
all_ids = [my_id] + replica_ids

state = 'candidate'
currentterm = 0
votedForMe = []
myvotes = {}

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = 0

leader = 'FFFF'

hearFromLeader = time.time()

readytovote = False
electionclock = time.time()
timeoutlength = random.uniform(.150, .300)

keepaliveclock = time.time()

transactionlog = []
statemachine = {}
 

while True:
        ready = select.select([sock], [], [], 0.1)[0]

        now = time.time()
        if state == 'candidate' and now - electionclock > timeoutlength:
                readytovote = True


        now = time.time()
        if now - hearFromLeader > 2 and not state == 'leader':
                readytovote = True


        if state == 'leader':
                now = time.time()
                if now - keepaliveclock > .5:
                        keepalive_msg = {
                                                'src' : my_id,
                                             'leader' : leader,
                                                'dst' : 'FFFF',
                                               'type' : 'keepalive',
                                        }
                        send(keepalive_msg)
                        keepaliveclock = time.time()

        if readytovote:
                currentterm += 1
                electionclock = time.time()
                timeoutlength = random.uniform(.150, .300)

                state = 'candidate'
                election_msg = {
                                        'src': my_id,
                                        'leader': 'FFFF',
                                        'dst': 'FFFF',
                                        'type': 'requestvote',
                                        'term': currentterm,
                                }
                send(election_msg)

                hearFromLeader = time.time()

                vote_msg = {
                                                'leader' : leader,
                                                'type'   : 'vote',
                                                'vote'   : my_id,
                                                'term'   : currentterm,
                                                'dst'    : 'FFFF',
                                                'src'    : my_id
                                           }
                send(vote_msg)

                votedForMe = [my_id]
                myvotes[currentterm] = my_id

                readytovote = False







        #######################
        #  RECIEVING MESSAGE  #
        #######################
        if sock in ready:
                msg_raw = sock.recv(32768)

                if len(msg_raw) == 0: continue
                msg = json.loads(msg_raw)


                if msg['src'] == leader:
                        hearFromLeader = time.time()


                if msg['type'] in ['get', 'put']:

                        if state == 'leader': 

                                if msg['type'] == 'get':
                                        key = msg['key']

                                        entry = LogEntry(       command= 'get',
                                                                    key= key,
                                                                  value= False,
                                                                   term= currentterm

                                                        )
                                        transactionlog.append(entry)


                                        value = statemachine.get(key)
                                        

                                        response_msg = {
                                                                "src": my_id, 
                                                                "dst": msg['src'], 
                                                             "leader": leader,
                                                               "type": "ok", 
                                                                "MID": msg['MID'], 
                                                              "value": value
                                                        }
                                        send(response_msg)

                                if msg['type'] == 'put':
                                        key = msg['key']
                                        value = msg['value']

                                        statemachine[key] = value

                                        entry = LogEntry(       command= 'put',
                                                                    key= key,
                                                                  value= value,
                                                                   term= currentterm
                                                        )
                                        transactionlog.append(entry)


                                        response_msg = {
                                                                "src": my_id, 
                                                                "dst": msg['src'], 
                                                             "leader": leader,
                                                               "type": "ok", 
                                                                "MID": msg['MID'], 
                                                        }
                                        send(response_msg)




                                # response_msg = {
                                #                         'src' : my_id,
                                #                         'dst' : msg['src'],
                                #                         'leader' : leader,
                                #                         'type' : 'fail',
                                #                         'MID' : msg['MID']
                                #                 }
                                # send(response_msg)


                        else: # redirect client to the leader
                                response_msg = {
                                                        'src' : my_id,
                                                        'dst' : msg['src'],
                                                        'leader' : leader,
                                                        'type' : 'redirect',
                                                        'MID' : msg['MID']
                                                }
                                send(response_msg)




                if msg['type'] == 'requestvote':

                        currentterm = msg['term']

                        if not myvotes.get(currentterm):
        	            	candidate = msg['src']
                                vote_msg = {
                                                'leader' : leader,
                                                'type'   : 'vote',
                                                'vote'   : candidate,
                                                'term'   : currentterm,
                                                'dst'    : 'FFFF',
                                                'src'    : my_id
                                           }
                                send(vote_msg)
                                myvotes[currentterm] = candidate

                        else: # I already voted this term
                                pass



                if msg['type'] == 'vote':
                        candidate = msg['vote']
                        electionterm = msg['term']

                        if candidate == my_id:
                                if electionterm > currentterm:
                                        currentterm = electionterm
                                        votedForMe = [msg['src']]

                                elif electionterm == currentterm:
                                        if not msg['src'] in votedForMe:
                                                votedForMe.append(msg['src'])

                                                print "{} {}    {}".format(my_id, currentterm, votedForMe) 

                                                if len(votedForMe) > len(all_ids) / 2:
                                                        leader = my_id
                                                        print '{} is the leader'.format(my_id)
                                                        state = 'leader'
                                                        broadcast_msg = {
                                                                                'leader' : my_id,
                                                                                'type'   : 'new-leader',
                                                                                'src'    : my_id,
                                                                                'dst'    : 'FFFF',
                                                                                'term'   : currentterm
                                                                        }

                                                        send(broadcast_msg)

                                else:
                                        pass
                                        #return false, voting for a previous term cannot go back in time

                                



                if msg['type'] == 'new-leader':
                        # check if the term is as expected?
                        state = 'follower'
                        leader = msg['leader']



                        











        clock = time.time()
        if clock - last > 4:
                print "{} is in state {}, thinks {} is leader of term {}".format(my_id, state, leader, currentterm)
                last = clock






#1  Add basic support for responding to client get() and put() requests. At this point, you can respond to all requests with a "type": "fail" message.
#2  Implement the Raft election protocol (section 5.2 of the Raft paper); add the ability to respond to get() and put() requests with "type": "redirect" messages.
#3  Add a timeout to detect leader failures (i.e. if you don't hear from the leader in X milliseconds...) and make sure that the new election proceeds correctly.
#4  Implement a basic, empty version of the AppendEntries RPC call that doesn't replicate any data, but acts as a keepalive message from the leader to other replicas to prevent unnecessary elections.
#5  Implement the transaction log and the "state machine" (i.e. a dictionary containing the key/value pairs from clients, Section 5.3). Don't bother replicating the transactions, just ensure that the leader is able to correctly answer get() and put() requests.

#6  Improve your AppendEntries RPC call to actually send data to replicas. Ensure that updates are only committing when a quorum is in agreement.
#7  Add support for retrying failed commits and test it by experimenting with lossy network simulations.
#8  If you haven't already, modify the leader election to support the additional restrictions in Section 5.4.1; test your implementation on lossy networks with failed leaders.
#9  Implement the subtle commit restriction given in Section 5.4.2.
#10 Test, test, test, and test some more ;)
# Step 6 will probably require the most time in terms of writing code and debugging, since it is the crux of the algorithm. Implementing steps 7-9 are necessary to ensure correctness of the protocol, but shouldn't be too difficult.