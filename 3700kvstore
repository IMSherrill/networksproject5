#!/usr/bin/env python

import sys
import socket
import select
import time
import json
import random
from datetime import datetime

class LogEntry:
        # def __init__(self, command, key, value, term):
        #         self.command = command
        #         self.key = key
        #         self.value = value
        #         self.term = term


        def __init__(self, initial_data):
                for key in initial_data:
                    setattr(self, key, initial_data[key])
                    committed = False


        def __repr__(self):
                if self.command == 'put':
                        return "{}    {} -> {}".format(self.term, self.key, self.value)

                if self.command == 'get':
                        return "{}     client <- {}".format(self.term, self.key)

        def toDict(self):
                return {
                                'command' : self.command,
                                'key' : self.key,
                                'value' : self.value,
                                'term' : self.term
                        }

        # TODO: why isnt this working?
        def commit(self):
                if self.command == 'put':
                        statemachine[self.key] = self.value
                        value = self.value
                        committed = True





def send(msg):
	sock.send(json.dumps(msg))

def getUncommittedEntries():
    return transactionlog[commitIndex:]

def getEntryWithThisMID(mid):
    for entry in transactionlog:
        if entry.MID == mid:
            return entry


my_id = sys.argv[1]
replica_ids = sys.argv[2:]
all_ids = [my_id] + replica_ids

state = 'candidate'
currentterm = 0
votedForMe = []
myvotes = {}

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = 0

leader = 'FFFF'

hearFromLeader = time.time()

readytovote = False
electionclock = time.time()
timeoutlength = random.uniform(.150, .300)

keepaliveclock = time.time()

transactionlog = []
statemachine = {}

logIndex = 0
commitIndex = 0

messageLog = {}
replicaCommitIndeces = {}



 

while True:
        logIndex = len(transactionlog)


        ready = select.select([sock], [], [], 0.1)[0]

        now = time.time()
        if state == 'candidate' and now - electionclock > timeoutlength:
                readytovote = True


        now = time.time()
        if now - hearFromLeader > 2 and not state == 'leader':
                readytovote = True


        if state == 'leader':
                now = time.time()
                if now - keepaliveclock > .5:
                        # TODO: keepalive might not be neccesary when i have implemented append entries RPC, if its empty it will function the same?
                        keepalive_msg = {
                                                'src' : my_id,
                                             'leader' : leader,
                                                'dst' : 'FFFF',
                                               'type' : 'keepalive',
                                        }
                        send(keepalive_msg)
                        keepaliveclock = time.time()

        if readytovote:
                currentterm += 1
                electionclock = time.time()
                timeoutlength = random.uniform(.150, .300)

                state = 'candidate'
                election_msg = {
                                        'src': my_id,
                                        'leader': 'FFFF',
                                        'dst': 'FFFF',
                                        'type': 'requestvote',
                                        'term': currentterm,
                                }
                send(election_msg)

                hearFromLeader = time.time()


                #TODO: this is probably not neccesary since everyone only keeps track of their own votes
                vote_msg = {
                                                'leader' : leader,
                                                'type'   : 'vote',
                                                'vote'   : my_id,
                                                'term'   : currentterm,
                                                'dst'    : 'FFFF',
                                                'src'    : my_id
                           }
                send(vote_msg)

                votedForMe = [my_id]
                myvotes[currentterm] = my_id

                readytovote = False







        #######################
        #  RECIEVING MESSAGE  #
        #######################
        if sock in ready:
                msg_raw = sock.recv(32768)

                if len(msg_raw) == 0: continue
                msg = json.loads(msg_raw)


                if msg['src'] == leader:
                        hearFromLeader = time.time()


                if msg['type'] in ['get', 'put']:

                        if state == 'leader': 

                            if msg['type'] == 'get':
                                key = msg['key']
                                response_value = statemachine.get(key, False)

                                if response_value:
                                    getresponse_msg = {
                                                            'src' : my_id,
                                                            'dst' : msg['src'],
                                                         'leader' : leader,
                                                           'type' : 'ok',
                                                           'MID'  : msg['MID'],
                                                        'value'   : value,
                                                    }
                                    send(getresponse_msg)

                                else:
                                    failresponse_msg = {
                                                            'src' : my_id,
                                                            'dst' : msg['src'],
                                                         'leader' : leader,
                                                           'type' : 'fail',
                                                           'MID'  : msg['MID'],
                                                    }
                                    send(failresponse_msg)


                            elif msg['type'] == 'put':
                                messageLog[msg['MID']] = msg['src']

                                key = msg['key']
                                value = msg['value']

                                entry = LogEntry({       
                                                        'command' : msg['type'],
                                                            'key' : key,
                                                          'value' : value,
                                                           'term' : currentterm,
                                                           'MID'  : msg['MID']

                                                })
                                transactionlog.append(entry)

                                appendentry_msg = {
                                                        'src' : my_id,
                                                        'dst' : 'FFFF',
                                                     'leader' : leader,
                                                       'type' : 'append-entries',
                                                      'entry' : entry.toDict(),
                                                      'term'  : currentterm,
                                                      # TODO: prevlogindex, prevlogterm, leaderCommit
                                               'prevLogIndex' : '',
                                                'prevLogTerm' : 0,
                                               'leaderCommit' : commitIndex
                                                  }
                                send(appendentry_msg)


                                # TODO: this is temporary until i make replicas commit
                                # if msg['type'] == 'put':
                                #         entry.commit()

                                value = statemachine.get(key, '')
                                
                                #TODO: only do this if its actually correct
                                response_msg = {
                                                        "src": my_id, 
                                                        "dst": msg['src'], 
                                                     "leader": leader,
                                                       "type": "ok", 
                                                        "MID": msg['MID'], 
                                                      "value": value
                                                }
                                send(response_msg)


                        else: # redirect client to the leader
                                redirect_msg = {
                                                        'src' : my_id,
                                                        'dst' : msg['src'],
                                                        'leader' : leader,
                                                        'type' : 'redirect',
                                                        'MID' : msg['MID']
                                                }
                                send(redirect_msg)




                if msg['type'] == 'requestvote':

                        currentterm = msg['term']

                        if not myvotes.get(currentterm):
        	            	candidate = msg['src']
                                vote_msg = {
                                                'leader' : leader,
                                                'type'   : 'vote',
                                                'vote'   : candidate,
                                                'term'   : currentterm,
                                                # the dst can probably just be the candidate
                                                # give this a try when its done
                                                # 'dst' : candidate,
                                                'dst'    : 'FFFF',
                                                'src'    : my_id
                                           }
                                send(vote_msg)
                                myvotes[currentterm] = candidate

                        else: # I already voted this term
                                pass



                if msg['type'] == 'vote':
                        candidate = msg['vote']
                        electionterm = msg['term']

                        if candidate == my_id:
                                if electionterm > currentterm:
                                        currentterm = electionterm
                                        votedForMe = [msg['src']]

                                elif electionterm == currentterm:
                                        if not msg['src'] in votedForMe:
                                                votedForMe.append(msg['src'])

                                                if len(votedForMe) > len(all_ids) / 2:
                                                        leader = my_id
                                                        print '{} is the leader'.format(my_id)
                                                        state = 'leader'
                                                        broadcast_msg = {
                                                                                'leader' : my_id,
                                                                                'type'   : 'new-leader',
                                                                                'src'    : my_id,
                                                                                'dst'    : 'FFFF',
                                                                                'term'   : currentterm
                                                                        }

                                                        send(broadcast_msg)

                                else:
                                        pass
                                        #return false, voting for a previous term cannot go back in time

                                


                if msg['type'] == 'new-leader':
                        # check if the term is as expected?
                        state = 'follower'
                        leader = msg['leader']




                if msg['type'] == 'append-entries':
                        newEntry = msg['entry']
                        entry = LogEntry(newEntry)
                        transactionlog.append(entry)
                        # indexToCommit = transactionlog.index(entry)

                        leaderCommitIndex = msg['leaderCommit']

                        for index in range(leaderCommitIndex+1, logIndex+1):
                            transactionlog[index].commit()
                            commitIndex = index


                        appendentry_response_msg = {
                                'leader' : leader,
                                'src' : my_id,
                                'dst' : leader,
                                'type' : 'append-entry-response',
                                'commitIndex' : commitIndex,
                                'logIndex' : logIndex,
                        }
                        send(appendentry_response_msg)


                if msg['type'] == 'append-entry-response':
                    replicaCommitIndeces[msg['src']] = msg['commitIndex']
                    print replicaCommitIndeces

                    unCommitted = getUncommittedEntries()

                    for index in range(commitIndex, logIndex): # transactionLog[index] are all uncommitted
                        numReplicasAlreadyCommittedThis = 0
                        for replica, cIndex in replicaCommitIndeces.iteritems():
                            if cIndex > index:
                                numReplicasAlreadyCommittedThis += 1

                        if numReplicasAlreadyCommittedThis > len(all_ids) / 2:
                            transactionlog[index].commit()
                            commitIndex = index
                            print 'leader committed at index {}'.format(index)










                        # TODO: commit needs to make sure everything before it is committed
                        # TODO: do we need to keep track of MID associated with log entry?












        clock = time.time()
        if clock - last > 4:
                print "{} is in state {}, thinks {} is leader of term {}".format(my_id, state, leader, currentterm)
                last = clock






#1  Add basic support for responding to client get() and put() requests. At this point, you can respond to all requests with a "type": "fail" message.
#2  Implement the Raft election protocol (section 5.2 of the Raft paper); add the ability to respond to get() and put() requests with "type": "redirect" messages.
#3  Add a timeout to detect leader failures (i.e. if you don't hear from the leader in X milliseconds...) and make sure that the new election proceeds correctly.
#4  Implement a basic, empty version of the AppendEntries RPC call that doesn't replicate any data, but acts as a keepalive message from the leader to other replicas to prevent unnecessary elections.
#5  Implement the transaction log and the "state machine" (i.e. a dictionary containing the key/value pairs from clients, Section 5.3). Don't bother replicating the transactions, just ensure that the leader is able to correctly answer get() and put() requests.

#6  Improve your AppendEntries RPC call to actually send data to replicas. Ensure that updates are only committing when a quorum is in agreement.

#7  Add support for retrying failed commits and test it by experimenting with lossy network simulations.
#8  If you haven't already, modify the leader election to support the additional restrictions in Section 5.4.1; test your implementation on lossy networks with failed leaders.
#9  Implement the subtle commit restriction given in Section 5.4.2.
#10 Test, test, test, and test some more ;)
# Step 6 will probably require the most time in terms of writing code and debugging, since it is the crux of the algorithm. Implementing steps 7-9 are necessary to ensure correctness of the protocol, but shouldn't be too difficult.