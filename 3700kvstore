#!/usr/bin/env python

import os
import sys
import socket
import select
import time
import json
import random
from datetime import datetime
from pprint import pprint

#### this keeps it from printing out, useful for when running ./test
# f = open(os.devnull, 'w')
# sys.stdout = f

class LogEntry:
        def __init__(self, initial_data):
                for key in initial_data:
                    setattr(self, key, initial_data[key])
                    self.committed = False


        def __repr__(self):
                if self.command == 'put':
                        return "{}    {} -> {}".format(self.term, self.key, self.value)

                if self.command == 'get':
                        return "{}     client <- {}".format(self.term, self.key)

        def toDict(self):
                return {
                                'command' : self.command,
                                'key' : self.key,
                                'value' : self.value,
                                'term' : self.term
                        }

        # TODO: why isnt this working?
        def commit(self):
            if not self.committed:
                statemachine[self.key] = self.value
                value = self.value
                self.committed = True
            else:
                pass
                # print "silly you already committed this, not committed because committing out of order can mess things up"





def send(msg):
	sock.send(json.dumps(msg))

def getIndexOfEntryWithThisMID(mid):
    index = 0
    while index < len(transactionlog):
        if transactionlog[index].MID == mid:
            return index


my_id = sys.argv[1]
replica_ids = sys.argv[2:]
all_ids = [my_id] + replica_ids

state = 'candidate'
currentterm = 0
votedForMe = []
myvotes = {}

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = 0

leader = 'FFFF'

hearFromLeader = time.time()

readytovote = False
electionclock = time.time()
timeoutlength = random.uniform(.150, .300)

keepaliveclock = time.time()

transactionlog = []
statemachine = {}

logIndex = 0
LastCommittedIndex = 0

messageLog = {}
replicaCommitIndeces = {}



 

while True:
        logIndex = len(transactionlog)


        ready = select.select([sock], [], [], 0.1)[0]

        now = time.time()
        if state == 'candidate' and now - electionclock > timeoutlength:
                readytovote = True


        now = time.time()
        if now - hearFromLeader > 2 and not state == 'leader':
                readytovote = True


        if state == 'leader':
                now = time.time()
                if now - keepaliveclock > .5:
                        # TODO: keepalive might not be neccesary when i have implemented append entries RPC, if its empty it will function the same?
                        keepalive_msg = {
                                                'src' : my_id,
                                             'leader' : leader,
                                                'dst' : 'FFFF',
                                               'type' : 'keepalive',
                                        }
                        send(keepalive_msg)
                        keepaliveclock = time.time()

        if readytovote:
                currentterm += 1
                print "{} requesting vote updating to term {}".format(my_id, currentterm)
                electionclock = time.time()
                timeoutlength = random.uniform(.150, .400)

                state = 'candidate'
                election_msg = {
                                        'src': my_id,
                                        'leader': 'FFFF',
                                        'dst': 'FFFF',
                                        'type': 'requestvote',
                                        'term': currentterm,
                                }
                send(election_msg)

                hearFromLeader = time.time()


                #TODO: this is probably not neccesary since everyone only keeps track of their own votes
                vote_msg = {
                                                'leader' : leader,
                                                'type'   : 'vote',
                                                'vote'   : my_id,
                                                'term'   : currentterm,
                                                'dst'    : 'FFFF',
                                                'src'    : my_id
                           }
                send(vote_msg)

                votedForMe = [my_id]
                myvotes[currentterm] = my_id

                readytovote = False







        #######################
        #  RECIEVING MESSAGE  #
        #######################
        if sock in ready:
                msg_raw = sock.recv(32768)

                if len(msg_raw) == 0: continue
                msg = json.loads(msg_raw)


                if msg['src'] == leader:
                        hearFromLeader = time.time()


                if msg['type'] in ['get', 'put']:

                        if state == 'leader': 

                            if msg['type'] == 'get':
                                response_value = False
                                key = msg['key']
                                #TODO: if there is no value for that key respond with empty string
                                response_value = statemachine.get(key, False)

                                if response_value:
                                    getresponse_msg = {
                                                            'src' : my_id,
                                                            'dst' : msg['src'],
                                                         'leader' : leader,
                                                           'type' : 'ok',
                                                           'MID'  : msg['MID'],
                                                        'value'   : response_value,
                                                    }
                                    send(getresponse_msg)

                                else:
                                    failresponse_msg = {
                                                            'src' : my_id,
                                                            'dst' : msg['src'],
                                                         'leader' : leader,
                                                           'type' : 'fail',
                                                           'MID'  : msg['MID'],
                                                    }
                                    send(failresponse_msg)


                            elif msg['type'] == 'put':

                                messageLog[msg['MID']] = msg['src']

                                key = msg['key']
                                value = msg['value']

                                entrydict = {       
                                                        'command' : msg['type'],
                                                            'key' : key,
                                                          'value' : value,
                                                           'term' : currentterm,
                                                           'MID'  : msg['MID']

                                                }

                                entry = LogEntry(entrydict)
                                transactionlog.append(entry)

                                appendentry_msg = {
                                                        'src' : my_id,
                                                        'dst' : 'FFFF',
                                                     'leader' : leader,
                                                       'type' : 'append-entries',
                                                      'entry' : entrydict,
                                                      'term'  : currentterm,
                                                # TODO: if leader has committed up to here, than you can too because quorum must have been reached
                                               'leaderCommit' : LastCommittedIndex
                                                  }
                                send(appendentry_msg)

                        elif state == 'candidate':
                            print '!!!!!!!!!!!!!!!!!!!!'

                        else: # redirect client to the leader
                            redirect_msg = {
                                                    'src' : my_id,
                                                    'dst' : msg['src'],
                                                    'leader' : leader,
                                                    'type' : 'redirect',
                                                    'MID' : msg['MID']
                                            }
                            send(redirect_msg)




                elif msg['type'] == 'requestvote':

                        currentterm = msg['term']

                        if not myvotes.get(currentterm):
        	            	candidate = msg['src']
                                vote_msg = {
                                                'leader' : leader,
                                                'type'   : 'vote',
                                                'vote'   : candidate,
                                                'term'   : currentterm,
                                                # the dst can probably just be the candidate
                                                # give this a try when its done
                                                # 'dst' : candidate,
                                                'dst'    : 'FFFF',
                                                'src'    : my_id
                                           }
                                send(vote_msg)
                                myvotes[currentterm] = candidate

                        else: # I already voted this term
                                pass



                elif msg['type'] == 'vote':
                        candidate = msg['vote']
                        electionterm = msg['term']

                        if candidate == my_id:
                                if electionterm > currentterm:
                                        currentterm = electionterm
                                        votedForMe = [msg['src']]

                                elif electionterm == currentterm:
                                        if not msg['src'] in votedForMe:
                                                votedForMe.append(msg['src'])

                                                if len(votedForMe) > len(all_ids) / 2:
                                                        leader = my_id
                                                        print '{} is the leader'.format(my_id)
                                                        state = 'leader'
                                                        broadcast_msg = {
                                                                                'leader' : my_id,
                                                                                'type'   : 'new-leader',
                                                                                'src'    : my_id,
                                                                                'dst'    : 'FFFF',
                                                                                'term'   : currentterm
                                                                        }

                                                        send(broadcast_msg)

                                else:
                                        pass
                                        #return false, voting for a previous term cannot go back in time

                                


                elif msg['type'] == 'new-leader':
                        # check if the term is as expected?
                        state = 'follower'
                        leader = msg['leader']




                elif msg['type'] == 'append-entries':

                        newEntry = msg['entry']
                        entry = LogEntry(newEntry)
                        transactionlog.append(entry)
                        # indexToCommit = transactionlog.index(entry)

                        leaderCommitIndex = msg['leaderCommit']

                        for index in range(leaderCommitIndex+1, len(transactionlog)):
                            transactionlog[index].commit()
                            # print 'follower committed at index {} of {}'.format(index, len(transactionlog))

                            LastCommittedIndex = index


                        appendentry_response_msg = {
                                'leader' : leader,
                                'src' : my_id,
                                'dst' : leader,
                                'type' : 'append-entry-response',
                                'LastCommittedIndex' : LastCommittedIndex,
                                'logIndex' : logIndex,
                        }
                        send(appendentry_response_msg)


                elif msg['type'] == 'append-entry-response':
                    replicaCommitIndeces[msg['src']] = msg['LastCommittedIndex']

                    for index in range(LastCommittedIndex + 1, len(transactionlog) + 1): # transactionLog[index] are all uncommitted
                        numReplicasAlreadyCommittedThis = 0
                        for replica, cIndex in replicaCommitIndeces.iteritems():
                            if cIndex >= index:
                                numReplicasAlreadyCommittedThis += 1

                        # TODO: Comment below?
                        if numReplicasAlreadyCommittedThis + 1 > len(all_ids) / 2: # the + 1 is to include myself (leader)
                            if not transactionlog[index].committed:

                                transactionlog[index].commit()
                                LastCommittedIndex = index
                                print 'leader committed at index {} of {}'.format(index, len(transactionlog))

                                entryMID = transactionlog[index].MID

                                # TODO: what would make this incorrect?
                                response_msg = {
                                                    'src' :  my_id,
                                                    'dst' :  messageLog.get(entryMID),
                                                 'leader' : leader,
                                                   'type' : 'ok',
                                                    'MID' : entryMID
                                }
                                send(response_msg)








                        # TODO: commit needs to make sure everything before it is committed



        # what to do if the leader receives a get request for a value that hasnt been committed yet but is in the log








        clock = time.time()
        if clock - last > 4:
                print "{} is in state {}, thinks {} is leader of term {}".format(my_id, state, leader, currentterm)
                last = clock
                if my_id == leader:
                    print "statemachine: {}".format(len(statemachine))
                    print "log {}".format(len(transactionlog))






#1  Add basic support for responding to client get() and put() requests. At this point, you can respond to all requests with a "type": "fail" message.
#2  Implement the Raft election protocol (section 5.2 of the Raft paper); add the ability to respond to get() and put() requests with "type": "redirect" messages.
#3  Add a timeout to detect leader failures (i.e. if you don't hear from the leader in X milliseconds...) and make sure that the new election proceeds correctly.
#4  Implement a basic, empty version of the AppendEntries RPC call that doesn't replicate any data, but acts as a keepalive message from the leader to other replicas to prevent unnecessary elections.
#5  Implement the transaction log and the "state machine" (i.e. a dictionary containing the key/value pairs from clients, Section 5.3). Don't bother replicating the transactions, just ensure that the leader is able to correctly answer get() and put() requests.

#6  Improve your AppendEntries RPC call to actually send data to replicas. Ensure that updates are only committing when a quorum is in agreement.

#7  Add support for retrying failed commits and test it by experimenting with lossy network simulations.
#8  If you haven't already, modify the leader election to support the additional restrictions in Section 5.4.1; test your implementation on lossy networks with failed leaders.
#9  Implement the subtle commit restriction given in Section 5.4.2.
#10 Test, test, test, and test some more ;)
# Step 6 will probably require the most time in terms of writing code and debugging, since it is the crux of the algorithm. Implementing steps 7-9 are necessary to ensure correctness of the protocol, but shouldn't be too difficult.